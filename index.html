<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Grade Distribution Analyzer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.24.2/plotly.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
        }
        .input-section, .output-section {
            background-color: #f9f9f9;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .control-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
        }
        textarea {
            width: 100%;
            height: 200px;
            margin-bottom: 10px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            resize: vertical;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
        }
        button:hover {
            background-color: #45a049;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .slider {
            flex-grow: 1;
        }
        input[type="number"] {
            width: 60px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .stats {
            margin: 20px 0;
            padding: 10px;
            background-color: #e9f7ef;
            border-radius: 4px;
        }
        #plotContainer {
            height: 400px;
            width: 100%;
            margin-top: 20px;
        }
        .failure-count {
            font-size: 1.2em;
            font-weight: bold;
            color: #d9534f;
            margin: 10px 0;
        }
        .error-message {
            color: #d9534f;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>Interactive Grade Distribution Analyzer</h1>
    <div class="container">
        <div class="input-section">
            <div class="control-group">
                <label for="gradesInput">Grades:</label>
                <textarea id="gradesInput" placeholder="Paste grades here, one per line..."></textarea>
                <button id="analyzeBtn">Analyze Grades</button>
            </div>
            
            <div class="control-group">
                <label for="failingThreshold">Failing Threshold:</label>
                <div class="slider-container">
                    <input type="range" id="failingThresholdSlider" min="0" max="100" value="60" class="slider">
                    <input type="number" id="failingThresholdInput" min="0" max="100" value="60">
                </div>
            </div>
            
            <div class="control-group">
                <label for="meanSlider">Mean:</label>
                <div class="slider-container">
                    <input type="range" id="meanSlider" min="0" max="100" value="70" step="0.1" class="slider" disabled>
                    <input type="number" id="meanInput" min="0" max="100" value="70" step="0.1" disabled>
                </div>
            </div>
            
            <div class="control-group">
                <label for="sdSlider">Standard Deviation:</label>
                <div class="slider-container">
                    <input type="range" id="sdSlider" min="0" max="30" value="10" step="0.1" class="slider" disabled>
                    <input type="number" id="sdInput" min="0" max="30" value="10" step="0.1" disabled>
                </div>
            </div>
        </div>
        
        <div class="output-section">
            <p id="errorMessage" class="error-message"></p>
            <div class="stats" id="statsDisplay"></div>
            <p class="failure-count" id="failureCount"></p>
            <div id="plotContainer"></div>
        </div>
    </div>

    <script>
        // Store the original and normalized grade arrays
        let originalGrades = [];
        let normalizedGrades = [];
        let hasValidGrades = false;

        // DOM Elements
        const gradesInput = document.getElementById('gradesInput');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const failingThresholdSlider = document.getElementById('failingThresholdSlider');
        const failingThresholdInput = document.getElementById('failingThresholdInput');
        const meanSlider = document.getElementById('meanSlider');
        const meanInput = document.getElementById('meanInput');
        const sdSlider = document.getElementById('sdSlider');
        const sdInput = document.getElementById('sdInput');
        const statsDisplay = document.getElementById('statsDisplay');
        const failureCount = document.getElementById('failureCount');
        const plotContainer = document.getElementById('plotContainer');
        const errorMessage = document.getElementById('errorMessage');

        // Initial setup
        initializeEventListeners();

        function initializeEventListeners() {
            // Button click event
            analyzeBtn.addEventListener('click', analyzeGrades);
            
            // Sync sliders with input boxes
            failingThresholdSlider.addEventListener('input', function() {
                failingThresholdInput.value = this.value;
                if (hasValidGrades) updateDisplayedGrades();
            });
            
            failingThresholdInput.addEventListener('input', function() {
                failingThresholdSlider.value = this.value;
                if (hasValidGrades) updateDisplayedGrades();
            });
            
            meanSlider.addEventListener('input', function() {
                meanInput.value = this.value;
                if (hasValidGrades) updateDisplayedGrades();
            });
            
            meanInput.addEventListener('input', function() {
                meanSlider.value = this.value;
                if (hasValidGrades) updateDisplayedGrades();
            });
            
            sdSlider.addEventListener('input', function() {
                sdInput.value = this.value;
                if (hasValidGrades) updateDisplayedGrades();
            });
            
            sdInput.addEventListener('input', function() {
                sdSlider.value = this.value;
                if (hasValidGrades) updateDisplayedGrades();
            });
        }

        function analyzeGrades() {
            // Clear previous messages
            errorMessage.textContent = '';
            
            // Parse and validate grades
            const inputText = gradesInput.value;
            const lines = inputText.split('\n');
            
            originalGrades = [];
            
            // Parse and validate each line
            for (const line of lines) {
                const trimmed = line.trim();
                if (trimmed === '') continue;
                
                const grade = parseFloat(trimmed);
                if (!isNaN(grade) && grade >= 0 && grade <= 100) {
                    originalGrades.push(grade);
                }
            }
            
            // Check if we have valid grades
            if (originalGrades.length === 0) {
                errorMessage.textContent = 'No valid grades found. Please enter numeric values between 0 and 100.';
                clearOutputs();
                hasValidGrades = false;
                return;
            }
            
            hasValidGrades = true;
            
            // Calculate statistics
            const mean = calculateMean(originalGrades);
            const sd = calculateStandardDeviation(originalGrades, mean);
            
            // Create normalized grades
            normalizedGrades = normalizeGrades(originalGrades, mean, sd);
            
            // Update UI controls
            meanSlider.value = mean.toFixed(1);
            meanInput.value = mean.toFixed(1);
            sdSlider.value = sd.toFixed(1);
            sdInput.value = sd.toFixed(1);
            
            // Enable controls
            meanSlider.disabled = false;
            meanInput.disabled = false;
            sdSlider.disabled = false;
            sdInput.disabled = false;
            
            // Add dynamic range for mean and SD
            const minGrade = Math.min(...originalGrades);
            const maxGrade = Math.max(...originalGrades);
            meanSlider.min = Math.max(0, minGrade - 20);
            meanSlider.max = Math.min(100, maxGrade + 20);
            meanInput.min = meanSlider.min;
            meanInput.max = meanSlider.max;
            
            // Update display
            updateStats(mean, sd);
            updateDisplayedGrades();
        }
        
        function calculateMean(grades) {
            if (grades.length === 0) return 0;
            const sum = grades.reduce((acc, grade) => acc + grade, 0);
            return sum / grades.length;
        }
        
        function calculateStandardDeviation(grades, mean) {
            if (grades.length <= 1) return 0;
            const sumSquaredDiff = grades.reduce((acc, grade) => {
                const diff = grade - mean;
                return acc + (diff * diff);
            }, 0);
            return Math.sqrt(sumSquaredDiff / grades.length);
        }
        
        function normalizeGrades(grades, mean, sd) {
            // Handle case where SD is 0
            if (sd === 0) {
                return grades.map(() => 0); // All normalized grades are 0 when SD is 0
            }
            
            // Normal case
            return grades.map(grade => (grade - mean) / sd);
        }
        
        function updateStats(mean, sd) {
            statsDisplay.innerHTML = `
                <strong>Original Grades Statistics:</strong><br>
                Number of Grades: ${originalGrades.length}<br>
                Mean: ${mean.toFixed(2)}<br>
                Standard Deviation: ${sd.toFixed(2)}<br>
                Min: ${Math.min(...originalGrades).toFixed(2)}<br>
                Max: ${Math.max(...originalGrades).toFixed(2)}
            `;
        }
        
        function updateDisplayedGrades() {
            // Get current UI values
            const currentMean = parseFloat(meanInput.value);
            const currentSd = parseFloat(sdInput.value);
            const threshold = parseFloat(failingThresholdInput.value);
            
            // Calculate displayed grades
            let displayedGrades;
            if (currentSd === 0) {
                // When SD is 0, all grades equal to mean
                displayedGrades = normalizedGrades.map(() => currentMean);
            } else {
                displayedGrades = normalizedGrades.map(normGrade => 
                    (normGrade * currentSd) + currentMean
                );
            }
            
            // Calculate failing count
            const failingCount = displayedGrades.filter(grade => grade < threshold).length;
            failureCount.textContent = `Number of Failing Students: ${failingCount}`;
            
            // Update textbox
            gradesInput.value = displayedGrades.map(grade => grade.toFixed(1)).join('\n');
            
            // Update the plot
            generatePlot(displayedGrades, threshold);
        }
        
        function generatePlot(grades, threshold) {
            // Create KDE data points
            const kdePoints = generateKDE(grades);
            
            // Find the failing portion of the curve
            const failingKDE = kdePoints.filter(point => point.x < threshold);
            
            // Create the overall curve
            const traceCurve = {
                x: kdePoints.map(point => point.x),
                y: kdePoints.map(point => point.y),
                mode: 'lines',
                name: 'Grade Distribution',
                line: {
                    color: 'blue',
                    width: 2
                },
                hoverinfo: 'none'
            };
            
            // Create the failing area
            const traceFailing = {
                x: failingKDE.map(point => point.x),
                y: failingKDE.map(point => point.y),
                fill: 'tozeroy',
                mode: 'lines',
                name: 'Failing Area',
                line: {
                    color: 'rgba(220, 53, 69, 0.7)',
                    width: 0
                },
                fillcolor: 'rgba(220, 53, 69, 0.3)',
                hoverinfo: 'none'
            };
            
            // Create the threshold line
            const traceThreshold = {
                x: [threshold, threshold],
                y: [0, Math.max(...kdePoints.map(p => p.y)) * 1.1],
                mode: 'lines',
                name: `Failing Threshold (${threshold})`,
                line: {
                    color: 'red',
                    width: 2,
                    dash: 'dash'
                }
            };
            
            // Plot layout
            const layout = {
                title: 'Grade Distribution',
                xaxis: {
                    title: 'Grade',
                    range: [0, 100]
                },
                yaxis: {
                    title: 'Probability Density',
                    zeroline: true
                },
                showlegend: true,
                margin: { t: 50, r: 50, b: 50, l: 50 },
                hovermode: 'closest'
            };
            
            // Plot the data
            Plotly.newPlot(plotContainer, [traceCurve, traceFailing, traceThreshold], layout);
        }
        
        function generateKDE(data) {
            // A simple KDE implementation for smoothing grade distribution
            const min = Math.min(...data) - 10;
            const max = Math.max(...data) + 10;
            
            // If all data is the same, return a spike at that value
            if (Math.min(...data) === Math.max(...data)) {
                const singleValue = data[0];
                return [
                    { x: singleValue - 0.1, y: 0 },
                    { x: singleValue, y: 1 },
                    { x: singleValue + 0.1, y: 0 }
                ];
            }
            
            // Handle KDE calculation
            const numPoints = 200;
            const stepSize = (max - min) / numPoints;
            const bandwidth = calculateBandwidth(data);
            
            // Generate points along x-axis
            const kdePoints = [];
            for (let i = 0; i <= numPoints; i++) {
                const x = min + (stepSize * i);
                let y = 0;
                
                // Calculate density at point x
                for (const dataPoint of data) {
                    // Gaussian kernel
                    const z = (x - dataPoint) / bandwidth;
                    y += Math.exp(-0.5 * z * z) / (bandwidth * Math.sqrt(2 * Math.PI));
                }
                
                y /= data.length; // Normalize
                kdePoints.push({ x, y });
            }
            
            return kdePoints;
        }
        
        function calculateBandwidth(data) {
            // Silverman's rule of thumb for bandwidth selection
            const n = data.length;
            const sd = calculateStandardDeviation(data, calculateMean(data));
            
            // If SD is 0 or very small, use a small default bandwidth
            if (sd < 0.001) return 1;
            
            // IQR-based estimator with fallback
            const sortedData = [...data].sort((a, b) => a - b);
            const q1Index = Math.floor(n * 0.25);
            const q3Index = Math.floor(n * 0.75);
            const iqr = sortedData[q3Index] - sortedData[q1Index];
            
            // If IQR is 0, use SD-based estimator
            if (iqr === 0) {
                return 0.9 * sd * Math.pow(n, -0.2);
            }
            
            // Use min of SD and IQR/1.34
            const h = 0.9 * Math.min(sd, iqr / 1.34) * Math.pow(n, -0.2);
            return h;
        }
        
        function clearOutputs() {
            statsDisplay.innerHTML = '';
            failureCount.textContent = '';
            Plotly.purge(plotContainer);
            
            // Disable controls
            meanSlider.disabled = true;
            meanInput.disabled = true;
            sdSlider.disabled = true;
            sdInput.disabled = true;
        }
    </script>
</body>
</html>